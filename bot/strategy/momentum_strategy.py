"""
Momentum Trading Strategy - Optimized for trending and high-volume market conditions.

This module implements a sophisticated momentum trading strategy that captures strong 
directional moves during trending markets, breakouts, and high-volume scenarios. It uses
multiple technical indicators, volume analysis, and trend detection to identify optimal
entry and exit points for momentum trades.

Key Features:
- Multi-timeframe trend analysis with EMA and ADX
- Advanced momentum indicators (MACD, RSI) with divergence detection
- Volume confirmation and spike detection
- Dynamic position sizing based on signal strength and volatility
- Comprehensive risk management with trailing stops
- Signal validation and strength scoring
- Integration with adaptive strategy manager

The strategy is designed for larger moves and longer holding periods compared to scalping,
typically holding positions from 5-30 minutes depending on momentum strength.
"""

import logging
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import pandas as pd

from ..config import settings
from ..indicators import calculate_atr
from ..types import MarketState, Position, TradeAction

logger = logging.getLogger(__name__)


class MomentumSignalType(Enum):
    """Types of momentum signals generated by the strategy."""
    TREND_CONTINUATION = "trend_continuation"
    BREAKOUT_BULLISH = "breakout_bullish"
    BREAKOUT_BEARISH = "breakout_bearish"
    MOMENTUM_DIVERGENCE = "momentum_divergence"
    VOLUME_SPIKE = "volume_spike"
    NONE = "none"


class MomentumSignalStrength(Enum):
    """Signal strength classifications."""
    WEAK = "weak"           # 60-70% confidence
    MODERATE = "moderate"   # 70-80% confidence  
    STRONG = "strong"       # 80-90% confidence
    VERY_STRONG = "very_strong"  # >90% confidence


@dataclass
class MomentumConfig:
    """Configuration parameters for the momentum strategy."""
    
    # Timeframe settings
    primary_timeframe: str = "1m"
    confirmation_timeframe: str = "5m"
    
    # Trend detection parameters
    ema_fast: int = 12
    ema_slow: int = 26
    trend_strength_min: float = 0.7
    
    # Momentum indicators
    macd_fast: int = 12
    macd_slow: int = 26
    macd_signal: int = 9
    rsi_period: int = 14
    adx_period: int = 14
    
    # Volume analysis
    volume_ma_period: int = 20
    volume_spike_threshold: float = 2.0
    volume_confirmation: bool = True
    
    # Entry criteria
    min_signal_strength: float = 0.7
    require_volume_confirmation: bool = True
    require_momentum_alignment: bool = True
    min_risk_reward: float = 2.0
    
    # Position sizing
    base_position_pct: float = 2.0
    max_position_pct: float = 5.0
    volatility_adjusted: bool = True
    
    # Risk management
    stop_loss_pct: float = 0.8
    take_profit_pct: float = 2.0
    trailing_stop: bool = True
    trailing_stop_activation: float = 1.0
    max_holding_time: int = 1800  # 30 minutes


class EMA:
    """Exponential Moving Average calculator."""
    
    def __init__(self, period: int):
        self.period = period
        self.alpha = 2.0 / (period + 1)
        self._ema_value = None
        
    def calculate(self, prices: pd.Series) -> pd.Series:
        """Calculate EMA for a series of prices."""
        if len(prices) == 0:
            return pd.Series(dtype=float)
            
        ema_values = np.zeros(len(prices))
        ema_values[0] = prices.iloc[0]
        
        for i in range(1, len(prices)):
            ema_values[i] = self.alpha * prices.iloc[i] + (1 - self.alpha) * ema_values[i-1]
            
        return pd.Series(ema_values, index=prices.index)


class SMA:
    """Simple Moving Average calculator."""
    
    def __init__(self, period: int):
        self.period = period
        
    def calculate(self, prices: pd.Series) -> pd.Series:
        """Calculate SMA for a series of prices."""
        return prices.rolling(window=self.period, min_periods=1).mean()


class ADX:
    """Average Directional Index calculator."""
    
    def __init__(self, period: int = 14):
        self.period = period
        
    def calculate(self, data: pd.DataFrame) -> pd.Series:
        """Calculate ADX from OHLC data."""
        if len(data) < self.period + 1:
            return pd.Series([25.0] * len(data), index=data.index)
            
        high = data['high']
        low = data['low']
        close = data['close']
        
        # Calculate True Range
        tr1 = high - low
        tr2 = abs(high - close.shift(1))
        tr3 = abs(low - close.shift(1))
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        
        # Calculate directional movements
        dm_plus = np.where((high.diff() > low.diff().abs()) & (high.diff() > 0), high.diff(), 0)
        dm_minus = np.where((low.diff().abs() > high.diff()) & (low.diff() < 0), low.diff().abs(), 0)
        
        # Convert to Series
        dm_plus = pd.Series(dm_plus, index=data.index)
        dm_minus = pd.Series(dm_minus, index=data.index)
        
        # Calculate smoothed values
        tr_smooth = tr.ewm(span=self.period).mean()
        dm_plus_smooth = dm_plus.ewm(span=self.period).mean()
        dm_minus_smooth = dm_minus.ewm(span=self.period).mean()
        
        # Calculate DI+ and DI-
        di_plus = 100 * dm_plus_smooth / tr_smooth
        di_minus = 100 * dm_minus_smooth / tr_smooth
        
        # Calculate DX
        dx = 100 * abs(di_plus - di_minus) / (di_plus + di_minus)
        dx = dx.fillna(0)
        
        # Calculate ADX
        adx = dx.ewm(span=self.period).mean()
        
        return adx.fillna(25.0)


class MACD:
    """MACD (Moving Average Convergence Divergence) calculator."""
    
    def __init__(self, fast_period: int = 12, slow_period: int = 26, signal_period: int = 9):
        self.fast_ema = EMA(fast_period)
        self.slow_ema = EMA(slow_period)
        self.signal_ema = EMA(signal_period)
        
    def calculate(self, prices: pd.Series) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """Calculate MACD line, signal line, and histogram."""
        fast_ema = self.fast_ema.calculate(prices)
        slow_ema = self.slow_ema.calculate(prices)
        
        macd_line = fast_ema - slow_ema
        signal_line = self.signal_ema.calculate(macd_line)
        histogram = macd_line - signal_line
        
        return macd_line, signal_line, histogram


class RSI:
    """Relative Strength Index calculator."""
    
    def __init__(self, period: int = 14):
        self.period = period
        
    def calculate(self, prices: pd.Series) -> pd.Series:
        """Calculate RSI for a series of prices."""
        if len(prices) < 2:
            return pd.Series([50.0] * len(prices), index=prices.index)
            
        delta = prices.diff()
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)
        
        avg_gain = gain.ewm(span=self.period).mean()
        avg_loss = loss.ewm(span=self.period).mean()
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi.fillna(50.0)


class MomentumTrendAnalyzer:
    """Analyzes trend direction and strength for momentum trading."""
    
    def __init__(self, config: MomentumConfig):
        self.config = config
        self.ema_fast = EMA(config.ema_fast)
        self.ema_slow = EMA(config.ema_slow)
        self.adx = ADX(config.adx_period)
        
    def analyze_trend(self, data: pd.DataFrame) -> Dict[str, Any]:
        """
        Analyze trend direction and strength.
        
        Args:
            data: OHLCV data
            
        Returns:
            Dictionary containing trend analysis results
        """
        try:
            # EMA trend direction
            ema_fast_values = self.ema_fast.calculate(data['close'])
            ema_slow_values = self.ema_slow.calculate(data['close'])
            
            # ADX trend strength
            adx_values = self.adx.calculate(data)
            
            # Current values
            current_price = data['close'].iloc[-1]
            current_ema_fast = ema_fast_values.iloc[-1]
            current_ema_slow = ema_slow_values.iloc[-1]
            current_adx = adx_values.iloc[-1]
            
            # Trend direction
            current_trend = self._determine_trend_direction(
                current_ema_fast, current_ema_slow, current_price
            )
            
            # Trend strength (normalized ADX)
            trend_strength = min(current_adx / 100.0, 1.0)
            
            # Trend momentum
            trend_momentum = self._calculate_trend_momentum(ema_fast_values, ema_slow_values)
            
            return {
                'direction': current_trend,
                'strength': trend_strength,
                'momentum': trend_momentum,
                'ema_fast': current_ema_fast,
                'ema_slow': current_ema_slow,
                'adx': current_adx,
                'is_trending': current_adx > 25
            }
            
        except Exception as e:
            logger.error(f"Error in trend analysis: {e}")
            return {
                'direction': 'neutral',
                'strength': 0.0,
                'momentum': 0.0,
                'ema_fast': 0.0,
                'ema_slow': 0.0,
                'adx': 25.0,
                'is_trending': False
            }
    
    def _determine_trend_direction(self, ema_fast: float, ema_slow: float, price: float) -> str:
        """Determine trend direction from EMA alignment."""
        if ema_fast > ema_slow and price > ema_fast:
            return 'bullish'
        elif ema_fast < ema_slow and price < ema_fast:
            return 'bearish'
        else:
            return 'neutral'
    
    def _calculate_trend_momentum(self, ema_fast: pd.Series, ema_slow: pd.Series) -> float:
        """Calculate trend momentum from EMA separation."""
        try:
            if len(ema_fast) < 5 or len(ema_slow) < 5:
                return 0.0
                
            # Calculate EMA separation
            current_separation = abs(ema_fast.iloc[-1] - ema_slow.iloc[-1])
            previous_separation = abs(ema_fast.iloc[-2] - ema_slow.iloc[-2])
            
            # Momentum is the rate of change in separation
            if previous_separation > 0:
                momentum = (current_separation - previous_separation) / previous_separation
                return max(-1.0, min(1.0, momentum))
            else:
                return 0.0
                
        except Exception:
            return 0.0


class MomentumIndicatorAnalyzer:
    """Analyzes momentum indicators for trading signals."""
    
    def __init__(self, config: MomentumConfig):
        self.config = config
        self.macd = MACD(config.macd_fast, config.macd_slow, config.macd_signal)
        self.rsi = RSI(config.rsi_period)
        
    def analyze_momentum(self, data: pd.DataFrame) -> Dict[str, Any]:
        """
        Analyze momentum indicators.
        
        Args:
            data: OHLCV data
            
        Returns:
            Dictionary containing momentum analysis results
        """
        try:
            # MACD analysis
            macd_line, macd_signal, macd_histogram = self.macd.calculate(data['close'])
            
            # RSI analysis
            rsi_values = self.rsi.calculate(data['close'])
            
            # Current values
            current_macd = macd_line.iloc[-1]
            current_signal = macd_signal.iloc[-1]
            current_histogram = macd_histogram.iloc[-1]
            current_rsi = rsi_values.iloc[-1]
            
            # MACD signals
            macd_signal_type = self._analyze_macd_signals(macd_line, macd_signal, macd_histogram)
            
            # RSI momentum
            rsi_momentum = self._analyze_rsi_momentum(rsi_values)
            
            # Divergence detection
            price_momentum_divergence = self._detect_momentum_divergence(
                data['close'], macd_line, rsi_values
            )
            
            return {
                'macd': {
                    'line': current_macd,
                    'signal': current_signal,
                    'histogram': current_histogram,
                    'signal_type': macd_signal_type,
                    'bullish_crossover': current_macd > current_signal and macd_histogram.iloc[-1] > macd_histogram.iloc[-2],
                    'bearish_crossover': current_macd < current_signal and macd_histogram.iloc[-1] < macd_histogram.iloc[-2]
                },
                'rsi': {
                    'value': current_rsi,
                    'momentum': rsi_momentum,
                    'overbought': current_rsi > 70,
                    'oversold': current_rsi < 30,
                    'bullish_momentum': current_rsi > 50 and rsi_momentum > 0,
                    'bearish_momentum': current_rsi < 50 and rsi_momentum < 0
                },
                'divergence': price_momentum_divergence
            }
            
        except Exception as e:
            logger.error(f"Error in momentum analysis: {e}")
            return {
                'macd': {
                    'line': 0.0, 'signal': 0.0, 'histogram': 0.0, 'signal_type': 'neutral',
                    'bullish_crossover': False, 'bearish_crossover': False
                },
                'rsi': {
                    'value': 50.0, 'momentum': 0.0, 'overbought': False, 'oversold': False,
                    'bullish_momentum': False, 'bearish_momentum': False
                },
                'divergence': None
            }
    
    def _analyze_macd_signals(self, macd_line: pd.Series, macd_signal: pd.Series, 
                             macd_histogram: pd.Series) -> str:
        """Analyze MACD for signal types."""
        try:
            if len(macd_line) < 2:
                return 'neutral'
                
            current_macd = macd_line.iloc[-1]
            current_signal = macd_signal.iloc[-1]
            prev_macd = macd_line.iloc[-2]
            prev_signal = macd_signal.iloc[-2]
            
            # Bullish crossover
            if current_macd > current_signal and prev_macd <= prev_signal:
                return 'bullish_crossover'
            
            # Bearish crossover
            if current_macd < current_signal and prev_macd >= prev_signal:
                return 'bearish_crossover'
            
            # Zero line crossovers
            if current_macd > 0 and prev_macd <= 0:
                return 'zero_line_bullish'
            if current_macd < 0 and prev_macd >= 0:
                return 'zero_line_bearish'
                
            return 'neutral'
            
        except Exception:
            return 'neutral'
    
    def _analyze_rsi_momentum(self, rsi_values: pd.Series) -> float:
        """Analyze RSI momentum."""
        try:
            if len(rsi_values) < 3:
                return 0.0
                
            # Calculate RSI momentum as rate of change
            current_rsi = rsi_values.iloc[-1]
            prev_rsi = rsi_values.iloc[-2]
            
            momentum = (current_rsi - prev_rsi) / 10.0  # Normalize
            return max(-1.0, min(1.0, momentum))
            
        except Exception:
            return 0.0
    
    def _detect_momentum_divergence(self, prices: pd.Series, macd_line: pd.Series, 
                                   rsi_values: pd.Series) -> Optional[str]:
        """Detect momentum divergence between price and indicators."""
        try:
            if len(prices) < 10:
                return None
                
            # Analyze recent trends (last 10 periods)
            recent_prices = prices.tail(10)
            recent_macd = macd_line.tail(10)
            recent_rsi = rsi_values.tail(10)
            
            # Price trend
            price_trend = (recent_prices.iloc[-1] - recent_prices.iloc[0]) / recent_prices.iloc[0]
            
            # MACD trend
            macd_trend = recent_macd.iloc[-1] - recent_macd.iloc[0]
            
            # RSI trend
            rsi_trend = recent_rsi.iloc[-1] - recent_rsi.iloc[0]
            
            # Bullish divergence: price down, indicators up
            if price_trend < -0.01 and (macd_trend > 0 or rsi_trend > 2):
                return 'bullish_divergence'
            
            # Bearish divergence: price up, indicators down
            if price_trend > 0.01 and (macd_trend < 0 or rsi_trend < -2):
                return 'bearish_divergence'
            
            return None
            
        except Exception:
            return None


class MomentumVolumeAnalyzer:
    """Analyzes volume patterns for momentum confirmation."""
    
    def __init__(self, config: MomentumConfig):
        self.config = config
        self.volume_ma = SMA(config.volume_ma_period)
        
    def analyze_volume(self, data: pd.DataFrame) -> Dict[str, Any]:
        """
        Analyze volume patterns and trends.
        
        Args:
            data: OHLCV data
            
        Returns:
            Dictionary containing volume analysis results
        """
        try:
            if 'volume' not in data.columns:
                return self._get_default_volume_analysis()
                
            volume_ma_values = self.volume_ma.calculate(data['volume'])
            current_volume = data['volume'].iloc[-1]
            avg_volume = volume_ma_values.iloc[-1] if not pd.isna(volume_ma_values.iloc[-1]) else current_volume
            
            # Volume metrics
            relative_volume = current_volume / avg_volume if avg_volume > 0 else 1.0
            volume_spike = relative_volume > self.config.volume_spike_threshold
            
            # Volume trend
            volume_trend = self._analyze_volume_trend(data['volume'])
            
            # Volume-price relationship
            volume_price_relationship = self._analyze_volume_price_relationship(
                data['close'], data['volume']
            )
            
            return {
                'current': current_volume,
                'average': avg_volume,
                'relative': relative_volume,
                'spike_detected': volume_spike,
                'trend': volume_trend,
                'price_relationship': volume_price_relationship,
                'confirmation': relative_volume > 1.2,  # Above average volume
                'strength': min(relative_volume / 2.0, 1.0)  # Normalized strength
            }
            
        except Exception as e:
            logger.error(f"Error in volume analysis: {e}")
            return self._get_default_volume_analysis()
    
    def _get_default_volume_analysis(self) -> Dict[str, Any]:
        """Return default volume analysis when data is unavailable."""
        return {
            'current': 1000.0,
            'average': 1000.0,
            'relative': 1.0,
            'spike_detected': False,
            'trend': 'neutral',
            'price_relationship': 'neutral',
            'confirmation': True,
            'strength': 0.5
        }
    
    def _analyze_volume_trend(self, volume: pd.Series) -> str:
        """Analyze volume trend direction."""
        try:
            if len(volume) < 5:
                return 'neutral'
                
            recent_volume = volume.tail(5)
            if recent_volume.iloc[-1] > recent_volume.mean() * 1.2:
                return 'increasing'
            elif recent_volume.iloc[-1] < recent_volume.mean() * 0.8:
                return 'decreasing'
            else:
                return 'neutral'
                
        except Exception:
            return 'neutral'
    
    def _analyze_volume_price_relationship(self, prices: pd.Series, volume: pd.Series) -> str:
        """Analyze relationship between volume and price changes."""
        try:
            if len(prices) < 2 or len(volume) < 2:
                return 'neutral'
                
            price_change = prices.iloc[-1] - prices.iloc[-2]
            volume_change = volume.iloc[-1] - volume.iloc[-2]
            
            # Positive correlation: both moving in same direction
            if (price_change > 0 and volume_change > 0) or (price_change < 0 and volume_change < 0):
                return 'confirming'
            # Negative correlation: moving in opposite directions
            elif (price_change > 0 and volume_change < 0) or (price_change < 0 and volume_change > 0):
                return 'diverging'
            else:
                return 'neutral'
                
        except Exception:
            return 'neutral'


class MomentumSignalGenerator:
    """Generates momentum trading signals from technical analysis."""
    
    def __init__(self, config: MomentumConfig):
        self.config = config
        self.trend_analyzer = MomentumTrendAnalyzer(config)
        self.momentum_analyzer = MomentumIndicatorAnalyzer(config)
        self.volume_analyzer = MomentumVolumeAnalyzer(config)
        
    def generate_signals(self, data: pd.DataFrame) -> List[Dict[str, Any]]:
        """
        Generate momentum trading signals.
        
        Args:
            data: OHLCV data
            
        Returns:
            List of momentum signals with strength and confidence scores
        """
        try:
            # Perform all analyses
            trend_analysis = self.trend_analyzer.analyze_trend(data)
            momentum_analysis = self.momentum_analyzer.analyze_momentum(data)
            volume_analysis = self.volume_analyzer.analyze_volume(data)
            
            signals = []
            
            # Trend continuation signals
            trend_signal = self._check_trend_continuation(
                trend_analysis, momentum_analysis, volume_analysis
            )
            if trend_signal:
                signals.append(trend_signal)
            
            # Breakout signals
            breakout_signal = self._check_breakout_signals(
                data, trend_analysis, volume_analysis
            )
            if breakout_signal:
                signals.append(breakout_signal)
            
            # Momentum divergence signals
            divergence_signal = self._check_momentum_divergence(
                momentum_analysis, trend_analysis
            )
            if divergence_signal:
                signals.append(divergence_signal)
            
            # Volume spike signals
            volume_signal = self._check_volume_spike_signals(
                volume_analysis, trend_analysis, data
            )
            if volume_signal:
                signals.append(volume_signal)
            
            # Filter and rank signals
            filtered_signals = self._filter_signals(signals, data)
            ranked_signals = self._rank_signals_by_strength(filtered_signals)
            
            return ranked_signals
            
        except Exception as e:
            logger.error(f"Error generating signals: {e}")
            return []
    
    def _check_trend_continuation(self, trend_analysis: Dict[str, Any], 
                                 momentum_analysis: Dict[str, Any], 
                                 volume_analysis: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Check for trend continuation signals."""
        try:
            # Trend continuation criteria
            conditions = {
                'strong_trend': trend_analysis['strength'] > self.config.trend_strength_min,
                'trend_direction': trend_analysis['direction'] in ['bullish', 'bearish'],
                'momentum_alignment': self._check_momentum_alignment(momentum_analysis, trend_analysis),
                'volume_confirmation': not self.config.require_volume_confirmation or volume_analysis['confirmation'],
                'macd_confirmation': momentum_analysis['macd']['signal_type'] in ['bullish_crossover', 'bearish_crossover', 'zero_line_bullish', 'zero_line_bearish']
            }
            
            # Calculate signal strength
            confidence = self._calculate_signal_confidence(conditions, trend_analysis, momentum_analysis)
            
            if confidence >= self.config.min_signal_strength:
                return {
                    'type': MomentumSignalType.TREND_CONTINUATION,
                    'direction': trend_analysis['direction'],
                    'strength': self._map_confidence_to_strength(confidence),
                    'confidence': confidence,
                    'entry_price': None,  # To be set by execution logic
                    'conditions': conditions,
                    'analysis': {
                        'trend': trend_analysis,
                        'momentum': momentum_analysis,
                        'volume': volume_analysis
                    }
                }
            
            return None
            
        except Exception as e:
            logger.error(f"Error checking trend continuation: {e}")
            return None
    
    def _check_breakout_signals(self, data: pd.DataFrame, trend_analysis: Dict[str, Any], 
                               volume_analysis: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Check for breakout signals."""
        try:
            if len(data) < 20:
                return None
                
            # Calculate recent high/low levels
            recent_data = data.tail(20)
            resistance_level = recent_data['high'].max()
            support_level = recent_data['low'].min()
            current_price = data['close'].iloc[-1]
            
            # Breakout conditions
            bullish_breakout = (
                current_price > resistance_level * 1.001 and  # Above resistance with buffer
                volume_analysis['spike_detected'] and
                trend_analysis['momentum'] > 0
            )
            
            bearish_breakout = (
                current_price < support_level * 0.999 and  # Below support with buffer
                volume_analysis['spike_detected'] and
                trend_analysis['momentum'] < 0
            )
            
            if bullish_breakout:
                confidence = min(0.9, volume_analysis['strength'] + trend_analysis['strength'])
                return {
                    'type': MomentumSignalType.BREAKOUT_BULLISH,
                    'direction': 'bullish',
                    'strength': self._map_confidence_to_strength(confidence),
                    'confidence': confidence,
                    'entry_price': current_price,
                    'breakout_level': resistance_level,
                    'analysis': {
                        'trend': trend_analysis,
                        'volume': volume_analysis
                    }
                }
            elif bearish_breakout:
                confidence = min(0.9, volume_analysis['strength'] + trend_analysis['strength'])
                return {
                    'type': MomentumSignalType.BREAKOUT_BEARISH,
                    'direction': 'bearish',
                    'strength': self._map_confidence_to_strength(confidence),
                    'confidence': confidence,
                    'entry_price': current_price,
                    'breakout_level': support_level,
                    'analysis': {
                        'trend': trend_analysis,
                        'volume': volume_analysis
                    }
                }
            
            return None
            
        except Exception as e:
            logger.error(f"Error checking breakout signals: {e}")
            return None
    
    def _check_momentum_divergence(self, momentum_analysis: Dict[str, Any], 
                                  trend_analysis: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Check for momentum divergence signals."""
        try:
            divergence = momentum_analysis.get('divergence')
            if not divergence:
                return None
                
            confidence = 0.6  # Base confidence for divergence signals
            
            # Enhance confidence based on trend strength
            if trend_analysis['strength'] > 0.5:
                confidence += 0.2
                
            if confidence >= self.config.min_signal_strength:
                direction = 'bullish' if divergence == 'bullish_divergence' else 'bearish'
                return {
                    'type': MomentumSignalType.MOMENTUM_DIVERGENCE,
                    'direction': direction,
                    'strength': self._map_confidence_to_strength(confidence),
                    'confidence': confidence,
                    'divergence_type': divergence,
                    'analysis': {
                        'momentum': momentum_analysis,
                        'trend': trend_analysis
                    }
                }
            
            return None
            
        except Exception as e:
            logger.error(f"Error checking momentum divergence: {e}")
            return None
    
    def _check_volume_spike_signals(self, volume_analysis: Dict[str, Any], 
                                   trend_analysis: Dict[str, Any], 
                                   data: pd.DataFrame) -> Optional[Dict[str, Any]]:
        """Check for volume spike signals."""
        try:
            if not volume_analysis['spike_detected']:
                return None
            
            # Volume spike must align with price movement
            if len(data) < 2:
                return None
                
            price_change = (data['close'].iloc[-1] - data['close'].iloc[-2]) / data['close'].iloc[-2]
            
            # Significant price movement with volume spike
            if abs(price_change) > 0.002:  # 0.2% minimum price movement
                direction = 'bullish' if price_change > 0 else 'bearish'
                confidence = min(0.8, volume_analysis['strength'] + abs(price_change) * 10)
                
                if confidence >= self.config.min_signal_strength:
                    return {
                        'type': MomentumSignalType.VOLUME_SPIKE,
                        'direction': direction,
                        'strength': self._map_confidence_to_strength(confidence),
                        'confidence': confidence,
                        'price_change_pct': price_change * 100,
                        'analysis': {
                            'volume': volume_analysis,
                            'trend': trend_analysis
                        }
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"Error checking volume spike signals: {e}")
            return None
    
    def _check_momentum_alignment(self, momentum_analysis: Dict[str, Any], 
                                 trend_analysis: Dict[str, Any]) -> bool:
        """Check if momentum indicators align with trend direction."""
        try:
            trend_direction = trend_analysis['direction']
            
            if trend_direction == 'bullish':
                return (
                    momentum_analysis['macd']['line'] > momentum_analysis['macd']['signal'] or
                    momentum_analysis['rsi']['bullish_momentum']
                )
            elif trend_direction == 'bearish':
                return (
                    momentum_analysis['macd']['line'] < momentum_analysis['macd']['signal'] or
                    momentum_analysis['rsi']['bearish_momentum']
                )
            else:
                return True  # Neutral trend, alignment not required
                
        except Exception:
            return False
    
    def _calculate_signal_confidence(self, conditions: Dict[str, bool], 
                                   trend_analysis: Dict[str, Any], 
                                   momentum_analysis: Dict[str, Any]) -> float:
        """Calculate overall signal confidence."""
        try:
            # Base confidence from condition fulfillment
            fulfilled_conditions = sum(1 for condition in conditions.values() if condition)
            base_confidence = fulfilled_conditions / len(conditions)
            
            # Enhance with trend strength
            trend_boost = trend_analysis['strength'] * 0.3
            
            # Enhance with momentum strength
            macd_strength = min(abs(momentum_analysis['macd']['histogram']) * 10, 0.2)
            rsi_strength = abs(momentum_analysis['rsi']['momentum']) * 0.2
            momentum_boost = (macd_strength + rsi_strength) / 2
            
            # Total confidence
            total_confidence = base_confidence + trend_boost + momentum_boost
            
            return min(1.0, total_confidence)
            
        except Exception:
            return 0.0
    
    def _map_confidence_to_strength(self, confidence: float) -> MomentumSignalStrength:
        """Map confidence score to signal strength enum."""
        if confidence >= 0.9:
            return MomentumSignalStrength.VERY_STRONG
        elif confidence >= 0.8:
            return MomentumSignalStrength.STRONG
        elif confidence >= 0.7:
            return MomentumSignalStrength.MODERATE
        else:
            return MomentumSignalStrength.WEAK
    
    def _filter_signals(self, signals: List[Dict[str, Any]], data: pd.DataFrame) -> List[Dict[str, Any]]:
        """Filter signals based on additional criteria."""
        filtered = []
        
        for signal in signals:
            # Skip signals that don't meet minimum confidence
            if signal.get('confidence', 0) < self.config.min_signal_strength:
                continue
                
            # Skip signals during low liquidity (if volume data available)
            if ('volume' in data.columns and 
                signal.get('analysis', {}).get('volume', {}).get('relative', 1.0) < 0.5):
                continue
            
            filtered.append(signal)
        
        return filtered
    
    def _rank_signals_by_strength(self, signals: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Rank signals by strength and confidence."""
        def signal_score(signal):
            confidence = signal.get('confidence', 0)
            strength_map = {
                MomentumSignalStrength.VERY_STRONG: 4,
                MomentumSignalStrength.STRONG: 3,
                MomentumSignalStrength.MODERATE: 2,
                MomentumSignalStrength.WEAK: 1
            }
            strength_score = strength_map.get(signal.get('strength'), 1)
            return confidence * 0.7 + (strength_score / 4) * 0.3
        
        return sorted(signals, key=signal_score, reverse=True)


class MomentumPositionSizer:
    """Calculates optimal position sizes for momentum trades."""
    
    def __init__(self, config: MomentumConfig):
        self.config = config
        
    def calculate_position_size(self, signal: Dict[str, Any], account_balance: float,
                               current_price: float, atr: float) -> Dict[str, Any]:
        """
        Calculate optimal position size for a momentum signal.
        
        Args:
            signal: Momentum signal dictionary
            account_balance: Available account balance
            current_price: Current market price
            atr: Average True Range for volatility measurement
            
        Returns:
            Dictionary containing position sizing information
        """
        try:
            # Base position size
            base_size = account_balance * (self.config.base_position_pct / 100)
            
            # Volatility adjustment
            if self.config.volatility_adjusted and atr > 0:
                volatility_multiplier = self._calculate_volatility_multiplier(atr, current_price)
                base_size *= volatility_multiplier
            
            # Signal strength adjustment
            strength_multiplier = self._get_strength_multiplier(signal.get('strength', MomentumSignalStrength.WEAK))
            position_size = base_size * strength_multiplier
            
            # Apply maximum position limit
            max_size = account_balance * (self.config.max_position_pct / 100)
            position_size = min(position_size, max_size)
            
            # Calculate stop loss and take profit
            stop_loss = self._calculate_stop_loss(signal, current_price, atr)
            take_profit = self._calculate_take_profit(signal, current_price, atr)
            
            # Risk/reward validation
            risk_amount = abs(current_price - stop_loss) * (position_size / current_price)
            reward_amount = abs(take_profit - current_price) * (position_size / current_price)
            risk_reward_ratio = reward_amount / risk_amount if risk_amount > 0 else 0
            
            # Adjust position size if risk/reward is poor
            if risk_reward_ratio < self.config.min_risk_reward:
                position_size *= 0.5  # Reduce position size for poor risk/reward
            
            return {
                'size': position_size,
                'size_usd': position_size,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'risk_amount': risk_amount,
                'reward_amount': reward_amount,
                'risk_reward_ratio': risk_reward_ratio,
                'volatility_adjusted': self.config.volatility_adjusted,
                'strength_multiplier': strength_multiplier
            }
            
        except Exception as e:
            logger.error(f"Error calculating position size: {e}")
            return {
                'size': account_balance * 0.01,  # 1% fallback
                'size_usd': account_balance * 0.01,
                'stop_loss': current_price * 0.995,
                'take_profit': current_price * 1.01,
                'risk_amount': account_balance * 0.005,
                'reward_amount': account_balance * 0.01,
                'risk_reward_ratio': 2.0,
                'volatility_adjusted': False,
                'strength_multiplier': 1.0
            }
    
    def _calculate_volatility_multiplier(self, atr: float, current_price: float) -> float:
        """Calculate volatility adjustment multiplier."""
        try:
            atr_percentage = (atr / current_price) * 100
            
            # Reduce position size for high volatility, increase for low volatility
            if atr_percentage > 2.0:  # High volatility
                return 0.7
            elif atr_percentage > 1.0:  # Medium volatility
                return 0.85
            elif atr_percentage < 0.5:  # Low volatility
                return 1.2
            else:  # Normal volatility
                return 1.0
                
        except Exception:
            return 1.0
    
    def _get_strength_multiplier(self, strength: MomentumSignalStrength) -> float:
        """Get position size multiplier based on signal strength."""
        multipliers = {
            MomentumSignalStrength.VERY_STRONG: 1.5,
            MomentumSignalStrength.STRONG: 1.2,
            MomentumSignalStrength.MODERATE: 1.0,
            MomentumSignalStrength.WEAK: 0.7
        }
        return multipliers.get(strength, 1.0)
    
    def _calculate_stop_loss(self, signal: Dict[str, Any], current_price: float, atr: float) -> float:
        """Calculate stop loss level."""
        try:
            direction = signal.get('direction', 'bullish')
            
            # Base stop loss percentage
            stop_loss_pct = self.config.stop_loss_pct / 100
            
            # ATR-based adjustment
            if atr > 0:
                atr_pct = (atr / current_price)
                stop_loss_pct = max(stop_loss_pct, atr_pct * 1.5)  # At least 1.5x ATR
            
            # Apply based on direction
            if direction == 'bullish':
                return current_price * (1 - stop_loss_pct)
            else:
                return current_price * (1 + stop_loss_pct)
                
        except Exception:
            # Fallback stop loss
            if signal.get('direction') == 'bullish':
                return current_price * 0.992
            else:
                return current_price * 1.008
    
    def _calculate_take_profit(self, signal: Dict[str, Any], current_price: float, atr: float) -> float:
        """Calculate take profit level."""
        try:
            direction = signal.get('direction', 'bullish')
            
            # Base take profit percentage
            take_profit_pct = self.config.take_profit_pct / 100
            
            # Signal strength adjustment
            strength = signal.get('strength', MomentumSignalStrength.MODERATE)
            if strength in [MomentumSignalStrength.VERY_STRONG, MomentumSignalStrength.STRONG]:
                take_profit_pct *= 1.5  # Larger targets for strong signals
            
            # Apply based on direction
            if direction == 'bullish':
                return current_price * (1 + take_profit_pct)
            else:
                return current_price * (1 - take_profit_pct)
                
        except Exception:
            # Fallback take profit
            if signal.get('direction') == 'bullish':
                return current_price * 1.02
            else:
                return current_price * 0.98


class MomentumStrategyExecutor:
    """Executes momentum trading strategy and manages positions."""
    
    def __init__(self, config: MomentumConfig):
        self.config = config
        self.signal_generator = MomentumSignalGenerator(config)
        self.position_sizer = MomentumPositionSizer(config)
        self.active_positions = {}
        
    async def execute_strategy(self, market_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute momentum strategy for current market conditions.
        
        Args:
            market_data: Dictionary containing market data and context
            
        Returns:
            Dictionary containing strategy execution results
        """
        try:
            data = market_data.get('ohlcv')
            current_price = market_data.get('current_price', 0)
            account_balance = market_data.get('account_balance', 0)
            
            if data is None or len(data) < 50:
                return self._get_default_result("Insufficient market data")
            
            # Generate momentum signals
            signals = self.signal_generator.generate_signals(data)
            
            # Calculate ATR for risk management
            atr = calculate_atr(data['high'], data['low'], data['close'])
            
            # Filter signals for entry
            entry_signals = [s for s in signals if self._should_enter_position(s)]
            
            # Manage existing positions
            position_updates = await self._manage_existing_positions(market_data)
            
            # Execute new entries (limit to 1 new position per cycle)
            new_positions = []
            for signal in entry_signals[:1]:
                position = await self._execute_entry(signal, current_price, account_balance, atr)
                if position:
                    new_positions.append(position)
            
            # Generate market analysis
            market_analysis = {
                'trend': self.signal_generator.trend_analyzer.analyze_trend(data),
                'momentum': self.signal_generator.momentum_analyzer.analyze_momentum(data),
                'volume': self.signal_generator.volume_analyzer.analyze_volume(data)
            }
            
            return {
                'strategy': 'momentum',
                'signals': signals,
                'new_positions': new_positions,
                'position_updates': position_updates,
                'market_analysis': market_analysis,
                'performance_metrics': self._calculate_performance_metrics(),
                'timestamp': time.time()
            }
            
        except Exception as e:
            logger.error(f"Error executing momentum strategy: {e}")
            return self._get_default_result(f"Strategy execution error: {str(e)}")
    
    def _get_default_result(self, reason: str) -> Dict[str, Any]:
        """Get default strategy result when execution fails."""
        return {
            'strategy': 'momentum',
            'signals': [],
            'new_positions': [],
            'position_updates': [],
            'market_analysis': {},
            'performance_metrics': {},
            'error': reason,
            'timestamp': time.time()
        }
    
    def _should_enter_position(self, signal: Dict[str, Any]) -> bool:
        """Determine if we should enter a position for this signal."""
        try:
            # Check confidence threshold
            if signal.get('confidence', 0) < self.config.min_signal_strength:
                return False
            
            # Check if we already have too many positions
            if len(self.active_positions) >= 3:  # Max 3 concurrent positions
                return False
            
            # Check signal type - avoid entering on divergence signals immediately
            if signal.get('type') == MomentumSignalType.MOMENTUM_DIVERGENCE:
                return signal.get('confidence', 0) > 0.8  # Higher threshold for divergence
            
            return True
            
        except Exception:
            return False
    
    async def _manage_existing_positions(self, market_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Manage existing momentum positions."""
        updates = []
        
        try:
            current_price = market_data.get('current_price', 0)
            current_time = time.time()
            
            for position_id, position in list(self.active_positions.items()):
                update = await self._update_position(position, current_price, current_time)
                if update:
                    updates.append(update)
                    
                    # Remove closed positions
                    if update.get('action') == 'close':
                        del self.active_positions[position_id]
            
            return updates
            
        except Exception as e:
            logger.error(f"Error managing positions: {e}")
            return []
    
    async def _update_position(self, position: Dict[str, Any], current_price: float, 
                              current_time: float) -> Optional[Dict[str, Any]]:
        """Update individual position based on current market conditions."""
        try:
            entry_price = position.get('entry_price', 0)
            entry_time = position.get('entry_time', current_time)
            direction = position.get('direction', 'bullish')
            stop_loss = position.get('stop_loss', 0)
            take_profit = position.get('take_profit', 0)
            
            # Check holding time limit
            if current_time - entry_time > self.config.max_holding_time:
                return {
                    'position_id': position.get('id'),
                    'action': 'close',
                    'reason': 'max_holding_time_exceeded',
                    'current_price': current_price
                }
            
            # Check stop loss
            if direction == 'bullish' and current_price <= stop_loss:
                return {
                    'position_id': position.get('id'),
                    'action': 'close',
                    'reason': 'stop_loss_hit',
                    'current_price': current_price
                }
            elif direction == 'bearish' and current_price >= stop_loss:
                return {
                    'position_id': position.get('id'),
                    'action': 'close',
                    'reason': 'stop_loss_hit',
                    'current_price': current_price
                }
            
            # Check take profit
            if direction == 'bullish' and current_price >= take_profit:
                return {
                    'position_id': position.get('id'),
                    'action': 'close',
                    'reason': 'take_profit_hit',
                    'current_price': current_price
                }
            elif direction == 'bearish' and current_price <= take_profit:
                return {
                    'position_id': position.get('id'),
                    'action': 'close',
                    'reason': 'take_profit_hit',
                    'current_price': current_price
                }
            
            # Check trailing stop (if enabled)
            if self.config.trailing_stop:
                trailing_update = self._update_trailing_stop(position, current_price)
                if trailing_update:
                    return trailing_update
            
            return None
            
        except Exception as e:
            logger.error(f"Error updating position: {e}")
            return None
    
    def _update_trailing_stop(self, position: Dict[str, Any], current_price: float) -> Optional[Dict[str, Any]]:
        """Update trailing stop for profitable positions."""
        try:
            entry_price = position.get('entry_price', 0)
            direction = position.get('direction', 'bullish')
            current_stop = position.get('stop_loss', 0)
            
            # Calculate unrealized profit percentage
            if direction == 'bullish':
                profit_pct = (current_price - entry_price) / entry_price
            else:
                profit_pct = (entry_price - current_price) / entry_price
            
            # Activate trailing stop when profit threshold is met
            if profit_pct >= (self.config.trailing_stop_activation / 100):
                # Calculate new trailing stop
                trail_distance = self.config.stop_loss_pct / 100
                
                if direction == 'bullish':
                    new_stop = current_price * (1 - trail_distance)
                    if new_stop > current_stop:  # Only move stop up
                        position['stop_loss'] = new_stop
                        return {
                            'position_id': position.get('id'),
                            'action': 'update_stop',
                            'new_stop_loss': new_stop,
                            'reason': 'trailing_stop_update'
                        }
                else:
                    new_stop = current_price * (1 + trail_distance)
                    if new_stop < current_stop:  # Only move stop down
                        position['stop_loss'] = new_stop
                        return {
                            'position_id': position.get('id'),
                            'action': 'update_stop',
                            'new_stop_loss': new_stop,
                            'reason': 'trailing_stop_update'
                        }
            
            return None
            
        except Exception:
            return None
    
    async def _execute_entry(self, signal: Dict[str, Any], current_price: float, 
                            account_balance: float, atr: float) -> Optional[Dict[str, Any]]:
        """Execute entry for a momentum signal."""
        try:
            # Calculate position size
            position_info = self.position_sizer.calculate_position_size(
                signal, account_balance, current_price, atr
            )
            
            # Validate risk/reward ratio
            if position_info['risk_reward_ratio'] < self.config.min_risk_reward:
                logger.info(f"Skipping signal due to poor risk/reward: {position_info['risk_reward_ratio']:.2f}")
                return None
            
            # Create position
            position_id = f"momentum_{int(time.time())}"
            position = {
                'id': position_id,
                'signal_type': signal['type'].value,
                'direction': signal['direction'],
                'entry_price': current_price,
                'entry_time': time.time(),
                'size': position_info['size'],
                'stop_loss': position_info['stop_loss'],
                'take_profit': position_info['take_profit'],
                'confidence': signal['confidence'],
                'strength': signal['strength'].value
            }
            
            # Store active position
            self.active_positions[position_id] = position
            
            return {
                'position_id': position_id,
                'action': 'open',
                'signal': signal,
                'position_info': position_info,
                'entry_price': current_price
            }
            
        except Exception as e:
            logger.error(f"Error executing entry: {e}")
            return None
    
    def _calculate_performance_metrics(self) -> Dict[str, Any]:
        """Calculate strategy performance metrics."""
        try:
            total_positions = len(self.active_positions)
            
            return {
                'active_positions': total_positions,
                'strategy_uptime': 1.0,  # Placeholder
                'avg_signal_confidence': 0.0,  # Would calculate from recent signals
                'last_update': time.time()
            }
            
        except Exception:
            return {}

    # Strategy Interface Methods (for integration with adaptive strategy manager)
    
    async def get_strategy_signals(self, market_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Get current momentum strategy signals."""
        try:
            data = market_data.get('ohlcv')
            if data is None or len(data) < 50:
                return []
            
            return self.signal_generator.generate_signals(data)
            
        except Exception as e:
            logger.error(f"Error getting strategy signals: {e}")
            return []
    
    async def validate_signal(self, signal: Dict[str, Any], market_data: Dict[str, Any]) -> bool:
        """Validate signal against current market conditions."""
        try:
            # Check basic signal validity
            if not signal or signal.get('confidence', 0) < self.config.min_signal_strength:
                return False
            
            # Check market conditions
            data = market_data.get('ohlcv')
            if data is None or len(data) < 10:
                return False
            
            # Additional validation logic can be added here
            return True
            
        except Exception as e:
            logger.error(f"Error validating signal: {e}")
            return False
    
    async def calculate_position_size(self, signal: Dict[str, Any], account_info: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate optimal position size for signal."""
        try:
            current_price = account_info.get('current_price', 0)
            account_balance = account_info.get('balance', 0)
            atr = account_info.get('atr', current_price * 0.01)  # Default 1% ATR
            
            return self.position_sizer.calculate_position_size(
                signal, account_balance, current_price, atr
            )
            
        except Exception as e:
            logger.error(f"Error calculating position size: {e}")
            return {}
    
    async def get_risk_parameters(self, signal: Dict[str, Any]) -> Dict[str, Any]:
        """Get risk management parameters for signal."""
        try:
            return {
                'stop_loss_pct': self.config.stop_loss_pct,
                'take_profit_pct': self.config.take_profit_pct,
                'max_holding_time': self.config.max_holding_time,
                'trailing_stop': self.config.trailing_stop,
                'max_position_pct': self.config.max_position_pct
            }
            
        except Exception as e:
            logger.error(f"Error getting risk parameters: {e}")
            return {}


# Default momentum strategy instance
def create_momentum_strategy(config: Optional[MomentumConfig] = None) -> MomentumStrategyExecutor:
    """Create a momentum strategy instance with optional custom configuration."""
    if config is None:
        config = MomentumConfig()
    
    return MomentumStrategyExecutor(config)